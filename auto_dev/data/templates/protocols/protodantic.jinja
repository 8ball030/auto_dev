import struct
from enum import Enum

from pydantic import BaseModel, confloat, conint


MAX_PROTO_SIZE = 2 * 1024 * 1024 * 1024  # 2 GiB in bytes

min_int32 = -1 << 31
max_int32 = (1 << 31) - 1
min_uint32 = 0
max_uint32 = (1 << 32) - 1

min_int64 = -1 << 63
max_int64 = (1 << 63) - 1
min_uint64 = 0
max_uint64 = (1 << 64) - 1

min_float32 = struct.unpack('f', struct.pack('I', 0xFF7FFFFF))[0]
max_float32 = struct.unpack('f', struct.pack('I', 0x7F7FFFFF))[0]
min_float64 = struct.unpack('d', struct.pack('Q', 0xFFEFFFFFFFFFFFFF))[0]
max_float64 = struct.unpack('d', struct.pack('Q', 0x7FEFFFFFFFFFFFFF))[0]
{#-#}
{%- set scalar_map = {
    "double": "confloat(ge=min_float64, le=max_float64)",
    "float": "confloat(ge=min_float32, le=max_float32)",
    "int32": "conint(ge=min_int32, le=max_int32)",
    "int64": "conint(ge=min_int64, le=max_int64)",
    "uint32": "conint(ge=min_uint32, le=max_uint32)",
    "uint64": "conint(ge=min_uint64, le=max_uint64)",
    "sint32": "conint(ge=min_int32, le=max_int32)",
    "sint64": "conint(ge=min_int64, le=max_int64)",
    "fixed32": "conint(ge=min_uint32, le=max_uint32)",
    "fixed64": "conint(ge=min_uint64, le=max_uint64)",
    "sfixed32": "conint(ge=min_int32, le=max_int32)",
    "sfixed64": "conint(ge=min_int64, le=max_int64)",
    "bool": "bool",
    "string": "str",
    "bytes": "bytes",
} %}
{#-#}
{%- set type_map = {
    "double": "float",
    "float": "float",
    "int32": "int",
    "int64": "int",
    "uint32": "int",
    "uint64": "int",
    "sint32": "int",
    "sint64": "int",
    "fixed32": "int",
    "fixed64": "int",
    "sfixed32": "int",
    "sfixed64": "int",
    "bool": "bool",
    "string": "str",
    "bytes": "bytes",
} %}
{#-#}

{# Define a list of enum names #}
{%- set enum_names = [] %}
{%- for enum in result.file_elements if enum.__class__.__name__ == "Enum" %}
{%- set enum_names = enum_names.append( enum.name ) %}
{%- endfor %}

{%- macro encode_scalar(element, message, full_name) -%}
    {%- if element.type in enum_names -%}
    proto_obj.{{ element.name }} = {{ message.name|lower }}.{{ element.name }}.value
    {%- elif scalar_map.get(element.type) not in scalar_map.values() -%}
    {{ full_name }}.{{ element.type }}.encode(proto_obj.{{ element.name }}, {{ message.name|lower }}.{{ element.name }})
    {%- else -%}
    proto_obj.{{ element.name }} = {{ message.name|lower }}.{{ element.name }}
    {%- endif -%}
{%- endmacro -%}

{%- macro decode_scalar(element, message, full_name) -%}
    decoded_{{ element.name }} = {% if element.type in enum_names -%}
        {{ element.type }}(proto_obj.{{ element.name }})
    {%- elif scalar_map.get(element.type) not in scalar_map.values() -%}
        {{ full_name }}.{{ element.type }}.decode(proto_obj.{{ element.name }})
    {%- else -%}
        proto_obj.{{ element.name }}
    {%- endif -%}
{%- endmacro -%}

{%- macro encode_optional(element, message, indent_level=2) -%}
    {%- set indent = '    ' * indent_level -%}
    if {{ message.name|lower }}.{{ element.name }} is not None:
    {{ indent }}{{ encode_scalar(element, message) }}
{%- endmacro -%}

{%- macro decode_optional(element, message) -%}
    {{ decode_scalar(element, message) }} if proto_obj.HasField("{{ element.name }}") else None
{%- endmacro -%}

{%- macro encode_repeated(element, message) -%}
    proto_obj.{{ element.name }}.extend({%- if element.type in enum_names -%}
        item.value
    {%- else -%}
        item
    {%- endif -%}
        {{ ' ' }}for item in {{ message.name|lower }}.{{ element.name }})
{%- endmacro -%}

{%- macro decode_repeated(element, message) -%}
    {%- if element.type in enum_names -%}
    decoded_{{ element.name }} = [{{ element.type }}(item) for item in proto_obj.{{ element.name }}]
    {%- else -%}
    decoded_{{ element.name }} = list(proto_obj.{{ element.name }})
    {%- endif -%}
{%- endmacro -%}

{#- First, generate Enums #}
{%- for enum in result.file_elements if enum.__class__.__name__ == "Enum" %}
class {{ enum.name }}(Enum):
{%- for value in enum.elements %}
    {{ value.name }} = {{ value.number }}
{%- endfor %}
{%- endfor %}

{%- macro render_message(message, prefix="", indent_level=1) %}
class {{ message.name }}(BaseModel):
    {%- set indent = '    ' * indent_level -%}
    {%- set prefix = (prefix + '.' if prefix else '') + message.name -%}
    {# Handle nested messages recursively #}
    {%- for nested in message.elements if nested.__class__.__name__ == "Message" %}
    {{indent}}{{ render_message(nested, prefix, indent_level + 1) | indent(4, true) }}
    {% endfor %}

    {%- for oneof in message.elements if oneof.__class__.__name__ == "OneOf" %}
    {{ oneof.name }}:
        {%- for field in oneof.elements -%}
        {{ ' ' }}{{ scalar_map.get(field.type, field.type) }}{{ " | " if not loop.last else "" }}
        {%- endfor %}
    {%- endfor %}

    {#- Handle fields of the message -#}
    {%- for field in message.elements if field.__class__.__name__ == "Field" %}
    {%- if field.cardinality == "REPEATED" %}
    {{ field.name }}: list[{{ scalar_map.get(field.type, field.type) }}]
    {%- elif field.cardinality == "OPTIONAL" %}
    {{ field.name }}: {{ scalar_map.get(field.type, field.type) }} | None
    {%- else %}
    {{ field.name }}: {{ scalar_map.get(field.type, field.type) }}
    {%- endif %}
    {%- endfor %}

    @staticmethod
    def encode(proto_obj, {{ message.name|lower }}: "{{ message.name }}") -> None:
    {%- for element in message.elements if element.__class__.__name__ == "Field" %}
    {%- if element.cardinality == "REPEATED" %}
        {{ encode_repeated(element, message) }}
    {%- elif element.cardinality == "OPTIONAL" %}
        {{ encode_optional(element, message) }}
    {%- else %}
        {{ encode_scalar(element, message, prefix) }}
    {%- endif %}
    {%- endfor %}

    {%- for element in message.elements if element.__class__.__name__ == "OneOf" %}
        {%- for field in element.elements %}
        if isinstance({{ message.name|lower }}.{{ element.name }}, {{ type_map.get(field.type, field.type) }}):
            proto_obj.{{ field.name }} = {{ message.name|lower }}.{{ element.name }}
        {%- endfor %}
    {%- endfor %}

    @classmethod
    def decode(cls, proto_obj) -> "{{ message.name }}":
    {%- for element in message.elements if element.__class__.__name__ == "Field" %}
    {%- if element.cardinality == "REPEATED" %}
        {{ decode_repeated(element, message) }}
    {%- elif element.cardinality == "OPTIONAL" %}
        {{ decode_optional(element, message) }}
    {%- else %}
        {{ decode_scalar(element, message, prefix) }}
    {%- endif %}
    {%- endfor %}

    {%- for element in message.elements if element.__class__.__name__ == "OneOf" %}
        oneof_data = {}
        {%- for field in element.elements %}
        if proto_obj.HasField("{{ field.name }}"):
            oneof_data["{{ element.name }}"] = proto_obj.{{ field.name }}
        {%- endfor %}
    {%- endfor %}

        return cls(
            {%- for element in message.elements if element.__class__.__name__ == "Field" %}
            {{ element.name }}=decoded_{{ element.name }}{{ "," if not loop.last else "" }}
            {%- endfor %}
            {%- if message.elements | selectattr("__class__.__name__", "equalto", "OneOf") | list | length > 0 -%}
            **oneof_data
            {%- endif -%}
        )

{%- endmacro %}

{# Now generate all message classes #}
{%- for message in result.file_elements if message.__class__.__name__ == "Message" %}
{{ render_message(message) }}
{%- endfor %}
