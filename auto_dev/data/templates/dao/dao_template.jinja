import json
from typing import Any
from pathlib import Path
from dataclasses import field, dataclass


@dataclass
class {{ model_name }}DAO:
    """{{ model_name }}DAO is a class that provides methods to interact with the {{ model_name }} data."""
    file_name: Path = field(default_factory=lambda: Path(__file__).parent / "aggregated_data.json")
    _data: dict[str, Any] = field(default_factory=dict, init=False)

    @property
    def data(self) -> dict[str, Any]:
        """Get the data for this model."""
        if not self._data:
            self.load_data()
        return self._data.get("{{ model_name }}", {})

    def load_data(self) -> None:
        """Load data from the file."""
        try:
            with open(self.file_name, encoding="utf-8") as f:
                self._data = json.load(f)
        except FileNotFoundError:
            self._data = {}

    def _save_data(self) -> None:
        """Save the updated model data to the file."""
        try:
            with open(self.file_name, "r", encoding="utf-8") as f:
                all_data = json.load(f)
        except FileNotFoundError:
            all_data = {}

        # Ensure all models are preserved
        for model in {{ other_model_names }}:
            if model not in all_data:
                all_data[model] = {}

        # Update only the relevant section
        all_data["{{ model_name }}"] = self._data["{{ model_name }}"]

        with open(self.file_name, "w", encoding="utf-8") as f:
            json.dump(all_data, f, indent=2)

    def insert(self, data: dict[str, Any] | list[dict[str, Any]]) -> None:
        """Insert a new item or items into the data."""
        self.load_data()  # Ensure we have the latest data
        
        if "{{ model_name }}" not in self._data:
            self._data["{{ model_name }}"] = {}
        
        existing_keys = set(map(int, self._data["{{ model_name }}"].keys()))
        if isinstance(data, list):
            for item in data:
                new_id = str(max(existing_keys, default=0) + 1)
                self._data["{{ model_name }}"][new_id] = item
                existing_keys.add(int(new_id))
        else:
            new_id = str(max(existing_keys, default=0) + 1)
            self._data["{{ model_name }}"][new_id] = data
        
        self._save_data()

    def get_all(self) -> list[dict[str, Any]]:
        """Get all items from the data."""
        return list(self._data.["{{ model_name }}"].values())

    def get_by_id(self, hashmap_key: str) -> dict[str, Any] | None:
        """Get an item by id."""
        if hashmap_key in self._data["{{ model_name }}"]:
            return self._data["{{ model_name }}"][hashmap_key]
        return None

    def filter_items(self, **kwargs) -> list[dict[str, Any]]:
        """Filter items by the given criteria."""
        return [{"id": key, **item} for key, item in self.data.items()
                if all(item.get(k) == v for k, v in kwargs.items())]

    def update(self, hashmap_key: str, **kwargs) -> dict[str, Any] | None:
        """Update an item by hashmap_key."""
        if hashmap_key in self._data["{{ model_name }}"]:
            self._data["{{ model_name }}"][hashmap_key].update(kwargs)
            self._save_data()
            return self._data["{{ model_name }}"][hashmap_key]
        return None

    def delete(self, hashmap_key: str) -> bool:
        """Delete an item by hashmap_key."""
        if hashmap_key in self._data["{{ model_name }}"]:
            del self._data["{{ model_name }}"][hashmap_key]
            self._save_data()
            return True
        return False

