import sys
import json
import random
import unittest
from copy import deepcopy
from pathlib import Path
from contextlib import contextmanager


sys.path.append(str(Path(__file__).parent / "dao"))

{% for i in range(dao_classes|length) %}
from {{ dao_file_names[i] }} import {{ dao_classes[i] }}
{% endfor %}


class TestDAOs(unittest.TestCase):
    """Test DAOs."""
    
    @classmethod
    def setUpClass(cls):
        """Setup class-level fixtures."""
        cls.data_file = Path(__file__).parent / "dao" / "aggregated_data.json"
        cls.backup_file = cls.data_file.with_suffix('.json.bak')
        
        # Create a backup of the original file
        cls.data_file.rename(cls.backup_file)

    @classmethod
    def tearDownClass(cls):
        """Tear down class-level fixtures."""
        # Restore the original file
        if cls.backup_file.exists():
            cls.backup_file.rename(cls.data_file)

    def setUp(self):
        """Setup DAOs and restore data file before each test."""
        {% for dao_class in dao_classes %}
        self.{{ dao_class.lower() }} = {{ dao_class }}()
        {% endfor %}
        self._restore_data_file()

    def tearDown(self):
        """Restore data file after each test."""
        self._restore_data_file()

    def _restore_data_file(self):
        """Restore the data file from the backup."""
        if self.backup_file.exists():
            self.backup_file.replace(self.data_file)

    @contextmanager
    def _data_file_context(self):
        """Context manager for data file operations."""
        try:
            yield
        finally:
            self._restore_data_file()

    {% for dao_class in dao_classes %}
    def test_{{ dao_class.lower() }}(self):
        """Test CRUD operations for {{ dao_class }}."""
        with self._data_file_context():
            dummy_data = {{ dummy_data.get(dao_class.replace("DAO", ""), {}) | tojson }}

            # Test insert
            try:
                self.{{ dao_class.lower() }}.insert(dummy_data)
                all_data = self.{{ dao_class.lower() }}.get_all()
                self.assertEqual(len(all_data), 6)
                self.assertTrue(any(item == dummy_data for item in all_data))
                print("Insert operation successful for {{ dao_class }}")
            except Exception as e:
                self.fail(f"Insert operation failed for {{ dao_class }}: {e}")

            # Test get_all
            try:
                result = self.{{ dao_class.lower() }}.get_all()
                self.assertIsInstance(result, list)
                self.assertEqual(len(result), 6)
                self.assertTrue(any(all(item[k] == v for k, v in dummy_data.items()) for item in result))
                print("Get all operation successful for {{ dao_class }}")
            except Exception as e:
                self.fail(f"Get all operation failed for {{ dao_class }}: {e}")

            # Test get_by_id
            try:
                all_items = self.{{ dao_class.lower() }}.get_all()

                result = self.{{ dao_class.lower() }}.get_by_id("6")

                self.assertIsNotNone(result)
                self.assertEqual(result, dummy_data)
                print("Get by id operation successful for {{ dao_class }}")
            except Exception as e:
                self.fail(f"Get by id operation failed for {{ dao_class }}: {e}")

            # Test update
            try:
                all_items = self.{{ dao_class.lower() }}.get_all()
                update_data = deepcopy(dummy_data)
                random_item = random.choice(range(len(all_items)))
                hashmap_key = str(random_item + 1)

                result = self.{{ dao_class.lower() }}.update(hashmap_key, **update_data)
                all_items = self.{{ dao_class.lower() }}.get_all()
                self.assertIsNotNone(result)
                self.assertEqual(update_data, all_items[int(hashmap_key) - 1])
                updated_item = self.{{ dao_class.lower() }}.get_by_id(hashmap_key)
                self.assertEqual(updated_item, update_data)
                print("Update operation successful for {{ dao_class }}")
            except Exception as e:
                self.fail(f"Update operation failed for {{ dao_class }}: {e}")

            # Test delete
            try:
                all_items = self.{{ dao_class.lower() }}.get_all()
                random_index = random.choice(range(len(all_items)))
                hashmap_key = str(random_index + 1)

                item_to_delete = all_items[int(hashmap_key) - 1]

                result = self.{{ dao_class.lower() }}.delete(hashmap_key)
                self.assertTrue(result)
                all_data_after_delete = self.{{ dao_class.lower() }}.get_all()
                self.assertEqual(len(all_data_after_delete), len(all_items) - 1)
                deleted_item = self.{{ dao_class.lower() }}.get_by_id(hashmap_key)
                self.assertIsNone(deleted_item)
                print("Delete operation successful for {{ dao_class }}")
            except Exception as e:
                self.fail(f"Delete operation failed for {{ dao_class }}: {e}")

    {% endfor %}

if __name__ == '__main__':
    unittest.main()