services:
  tendermint:
    user: "1000"
    mem_limit: 1024m
    mem_reservation: 256M
    cpus: 0.5
    container_name: tm_0
    hostname: tm_0
    image: "valory/open-autonomy-tendermint:0.15.2"
    restart: always
    network_mode: host
    environment:
      - ID=0
      - TMHOME=/tendermint/node0
      - CREATE_EMPTY_BLOCKS=true
      - DEV_MODE=0
      - LOG_FILE=node_0.txt
      - LOG_LEVEL=INFO
      - WRITE_TO_LOG=true
      - HOST_NAME=localhost
    working_dir: /tendermint
    entrypoint: []
    command:
      - /bin/sh
      - -c
      - |
        # Initialize Tendermint if needed
        if [ ! -d "/tendermint/node0/config" ]; then
            echo "Initializing Tendermint..."
            rm -rf /tendermint/node0
            mkdir -p /tendermint/node0
            tendermint init validator
            chown -R 1000:1000 /tendermint/
        fi

        # Wait a bit for previous processes to fully shut down
        echo "Waiting for ports to be released..."
        sleep 3

        # Show current listening ports and processes
        echo "Current listening ports (netstat):"
        netstat -tuln || true
        echo "Processes listening on our ports:"
        lsof -i :8081-8095 || true

        # Try each port using Python socket binding
        python3 - << 'PYEOF' > /tmp/port.txt
        import socket
        import errno
        ports = [8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095]
        for p in ports:
            try:
                print(f"\nTesting port {p}...")
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.bind(('127.0.0.1', p))
                s.close()
                print(f"Port {p} is available (bind succeeded)")
                print(p)  # This will be captured in the port variable
                break
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    print(f"Port {p} is in use (Address already in use)")
                    # Show what's using the port
                    import subprocess
                    subprocess.run(['lsof', '-i', f':{p}'])
                else:
                    print(f"Port {p} error: {e} (errno={e.errno})")
        PYEOF

        port=$$(grep -oE '^[0-9]+$$' /tmp/port.txt | tail -n 1)
        if [ -z "$$port" ]; then
            echo "No ports available"
            exit 1
        fi

        proxy_app="tcp://127.0.0.1:$$port"
        export PROXY_APP="$$proxy_app"

        echo "Starting Flask on port $$port"
        flask run --no-reload --host=127.0.0.1 --port=$$port &
        flask_pid=$$!

        # Wait for Flask to start and verify it's running
        sleep 2
        if ! kill -0 $$flask_pid 2>/dev/null; then
            echo "Flask failed to start"
            exit 1
        fi

        echo "Starting Tendermint with proxy_app pointing to Flask on port $$port"
        tendermint node --proxy_app="$$proxy_app" --rpc.laddr=tcp://0.0.0.0:26657 --p2p.laddr=tcp://0.0.0.0:26656 --p2p.seeds= --consensus.create_empty_blocks=true --abci=socket --home /tendermint/node0
    ports:
      - 26656:26656
      - 26657:26657
    extra_hosts:
      - "host.docker.internal:host-gateway"
    volumes:
      - tendermint:/tendermint/
      - ../../..:/app
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8090"]
      interval: 10s
      timeout: 10s
      retries: 3

volumes:
  tendermint:
